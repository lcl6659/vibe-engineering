name: Vibe Backend Agent

on:
  issue_comment:
    types: [created]

jobs:
  backend-agent:
    if: contains(github.event.comment.body, '/agent-be')
    runs-on: ubuntu-latest

    permissions:
      issues: write
      contents: write
      pull-requests: write

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v5

      - name: Setup Git
        run: |
          git config user.name "vibe-backend-agent"
          git config user.email "agent@vibe.dev"

      - name: Vibe Backend Agent - Prepare Context
        uses: actions/github-script@v7
        id: prepare-context
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        with:
          script: |
            const fs = require("fs");
            const path = require("path");
            const { execSync } = require("child_process");

            async function runBackendAgent() {
              const { owner, repo } = context.repo;
              const issue_number = context.issue.number;
              const commentBody = context.payload.comment.body;

              // ==================== ä¸Šä¸‹æ–‡ä¿¡æ¯è¾“å‡º ====================
              console.log("=".repeat(80));
              console.log("ğŸ” BACKEND AGENT - ä¸Šä¸‹æ–‡ä¿¡æ¯");
              console.log("=".repeat(80));
              console.log(`ğŸ“¦ Repository: ${owner}/${repo}`);
              console.log(`ğŸ“‹ Issue Number: #${issue_number}`);
              console.log(`ğŸ‘¤ Comment Author: ${context.payload.comment.user.login}`);
              console.log(`ğŸ• Comment Created: ${context.payload.comment.created_at}`);
              console.log(`ğŸ”— Comment URL: ${context.payload.comment.html_url}`);
              console.log("");
              console.log("ğŸ“ æ”¶åˆ°çš„è¯„è®ºå†…å®¹ (å®Œæ•´):");
              console.log("-".repeat(80));
              console.log(commentBody);
              console.log("-".repeat(80));
              console.log("");

              // 1. Extract UI Spec URLs (æ”¯æŒå¤šä¸ª URLï¼Œæ”¯æŒ issue å’Œ comment)
              // æ”¯æŒ GitHub è‡ªåŠ¨è½¬æ¢çš„ markdown é“¾æ¥æ ¼å¼: [#139 (comment)](https://...)
              // æ”¯æŒä¸‰ç§æ ¼å¼ï¼š
              // - Issue URL (å¸¦é”šç‚¹): https://github.com/owner/repo/issues/166#issue-3791738749
              // - Issue URL (ä¸å¸¦é”šç‚¹): https://github.com/owner/repo/issues/161
              // - Comment URL: https://github.com/owner/repo/issues/139#issuecomment-123456
              const urlPattern = /https:\/\/github\.com\/[^\s\)]+\/issues\/\d+(?:#(?:issuecomment-|issue-)\d+)?/g;
              const urlMatches = commentBody.match(urlPattern) || [];

              console.log(`ğŸ” æ‰¾åˆ° ${urlMatches.length} ä¸ª URL:`);
              urlMatches.forEach((url, idx) => {
                console.log(`  ${idx + 1}. ${url}`);
              });
              console.log("");

              // å¦‚æœæ²¡æœ‰æä¾› URLï¼Œåˆ™é»˜è®¤ä½¿ç”¨å½“å‰ Issue çš„å†…å®¹
              let useCurrentIssue = false;
              if (urlMatches.length === 0) {
                console.log("âš ï¸ æœªæä¾› URLï¼Œå°†ä½¿ç”¨å½“å‰ Issue å†…å®¹ä½œä¸ºéœ€æ±‚");
                useCurrentIssue = true;
              }

              // 1.1 Extract user instructions (text after URLs)
              let userInstructions = commentBody
                .replace(/\/agent-be\s*/, "")
                .trim();
              
              // Remove all URLs from instructions
              urlMatches.forEach(url => {
                userInstructions = userInstructions.replace(url, "").trim();
              });

              console.log("ğŸ“Œ æå–çš„ç”¨æˆ·é¢å¤–æŒ‡ä»¤:");
              console.log("-".repeat(80));
              console.log(userInstructions || "(æ— )");
              console.log("-".repeat(80));
              console.log("");

              // 2. Fetch all UI Specs from multiple URLs (æ”¯æŒ issue å’Œ comment)
              const uiSpecs = [];
              const specUrls = [];

              if (useCurrentIssue) {
                // ä½¿ç”¨å½“å‰ Issue çš„å†…å®¹ä½œä¸ºéœ€æ±‚
                const issueData = context.payload.issue;
                const content = issueData.body || "";
                const title = issueData.title;
                const url = `https://github.com/${owner}/${repo}/issues/${issue_number}`;
                uiSpecs.push({ url, content, title });
                specUrls.push(url);
                console.log(`âœ… ä½¿ç”¨å½“å‰ Issue: ${title}`);
                console.log(`   å†…å®¹é•¿åº¦: ${content.length} å­—ç¬¦`);
                console.log(`   å†…å®¹é¢„è§ˆ: ${content.substring(0, 200)}${content.length > 200 ? '...' : ''}`);
              }

              for (const specUrl of urlMatches) {
                try {
                  // åˆ¤æ–­ URL ç±»å‹ï¼šissue è¿˜æ˜¯ comment
                  const isCommentUrl = specUrl.includes("#issuecomment-");
                  const isIssueUrlWithAnchor = specUrl.includes("#issue-");
                  // å¦‚æœæ²¡æœ‰ comment æˆ– issue é”šç‚¹ï¼Œåˆ™è§†ä¸ºçº¯ issue URL
                  const isIssueUrl = !isCommentUrl && (isIssueUrlWithAnchor || !specUrl.includes("#"));
                  
                  let specContent;
                  let specTitle;
                  
                  if (isIssueUrl) {
                    // æå– issue numberï¼ˆæ”¯æŒå¸¦é”šç‚¹å’Œä¸å¸¦é”šç‚¹çš„æ ¼å¼ï¼‰
                    const issueMatch = specUrl.match(/\/issues\/(\d+)/);
                    if (!issueMatch) {
                      throw new Error(`æ— æ³•è§£æ Issue URL: ${specUrl}`);
                    }
                    const issueNum = Number(issueMatch[1]);
                    console.log(`ğŸ“¥ è·å– Issue å†…å®¹: ${specUrl} (Issue #${issueNum})`);
                    
                    const issueRes = await github.rest.issues.get({
                      owner,
                      repo,
                      issue_number: issueNum
                    });
                    
                    specContent = issueRes.data.body || "";
                    specTitle = issueRes.data.title || specContent.split('\n')[0] || 'UI Spec';
                    
                    console.log(`âœ… æˆåŠŸè·å– Issue #${issueNum}, å†…å®¹é•¿åº¦: ${specContent.length}`);
                    console.log(`   æ ‡é¢˜: ${specTitle}`);
                    console.log(`   å†…å®¹é¢„è§ˆ: ${specContent.substring(0, 200)}${specContent.length > 200 ? '...' : ''}`);
                  } else if (isCommentUrl) {
                    // æå– comment ID
                    const commentId = specUrl.split("#issuecomment-")[1];
                    console.log(`ğŸ“¥ è·å–è¯„è®ºå†…å®¹: ${specUrl} (Comment ID: ${commentId})`);
                    
                    const commentRes = await github.rest.issues.getComment({
                      owner,
                      repo,
                      comment_id: Number(commentId)
                    });
                    
                    specContent = commentRes.data.body;
                    specTitle = specContent.split('\n')[0] || 'UI Spec';
                    
                    console.log(`âœ… æˆåŠŸè·å–è¯„è®º ${commentId}, å†…å®¹é•¿åº¦: ${specContent.length}`);
                    console.log(`   æ ‡é¢˜: ${specTitle}`);
                    console.log(`   å†…å®¹é¢„è§ˆ: ${specContent.substring(0, 200)}${specContent.length > 200 ? '...' : ''}`);
                  } else {
                    throw new Error(`ä¸æ”¯æŒçš„ URL æ ¼å¼: ${specUrl}`);
                  }
                  
                  uiSpecs.push({
                    url: specUrl,
                    content: specContent,
                    title: specTitle
                  });
                  specUrls.push(specUrl);
                } catch (error) {
                  console.error(`âŒ è·å–å†…å®¹å¤±è´¥ ${specUrl}:`, error.message);
                  await github.rest.issues.createComment({
                    owner,
                    repo,
                    issue_number,
                    body: `âŒ **è·å–å†…å®¹å¤±è´¥**: ${specUrl}\n\né”™è¯¯: ${error.message}`
                  });
                  return;
                }
              }

              // 2.1 Combine all UI Specs
              const combinedUISpec = uiSpecs.map((spec, idx) => {
                return `## UI Spec ${idx + 1}: ${spec.title}\n\næ¥æº: ${spec.url}\n\n${spec.content}`;
              }).join("\n\n---\n\n");

              console.log(`ğŸ“‹ åˆå¹¶åçš„ UI Spec æ€»é•¿åº¦: ${combinedUISpec.length} å­—ç¬¦`);
              console.log(`ğŸ“‹ UI Spec å†…å®¹é¢„è§ˆ:`);
              console.log("-".repeat(80));
              console.log(combinedUISpec.substring(0, 500) + (combinedUISpec.length > 500 ? '\n...' : ''));
              console.log("-".repeat(80));
              console.log("");

              // 3. Derive API contract
              const contractPrompt = `ä½ æ˜¯ä¸€ä¸ªåç«¯ API å¥‘çº¦è®¾è®¡ä¸“å®¶ã€‚

              è¯·åŸºäºä»¥ä¸‹å†»ç»“çš„ UI Spec${uiSpecs.length > 1 ? 'ï¼ˆåŒ…å«å¤šä¸ª UI Specï¼‰' : ''}ï¼Œæ¨å¯¼å‰åç«¯å¯¹é½æ‰€éœ€çš„æœ€å° API å¥‘çº¦ã€‚

              ${userInstructions ? `ç”¨æˆ·é¢å¤–æŒ‡ä»¤:\n${userInstructions}\n\n` : ''}UI Spec å†…å®¹:
              ${combinedUISpec}

              è¯·åˆ†ææ‰€æœ‰ UI Specï¼Œæå–å‡ºæ‰€æœ‰éœ€è¦çš„å‰åç«¯äº¤äº’æ¥å£ï¼Œè¿”å› JSON æ•°ç»„æ ¼å¼ï¼š
              [
                {
                  "endpoint": "/api/parse",
                  "method": "POST",
                  "description": "Parse YouTube/Twitter URL",
                  "request": {
                    "url": "string"
                  },
                  "response": {
                    "source": "youtube | twitter",
                    "title": "string",
                    "author": "string",
                    "summary": "string",
                    "originalUrl": "string"
                  },
                  "errors": [
                    { "code": "INVALID_URL", "message": "Unsupported URL" },
                    { "code": "PARSE_FAILED", "message": "Unable to parse content" }
                  ]
                }
              ]

              å¦‚æœåªæœ‰ä¸€ä¸ªæ¥å£ï¼Œä¹Ÿå¯ä»¥è¿”å›å•ä¸ªå¯¹è±¡ï¼ˆä¸æ˜¯æ•°ç»„ï¼‰ã€‚

              åªè¿”å› JSONï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚`;

              const contractRes = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                method: "POST",
                headers: {
                  "Authorization": `Bearer ${process.env.OPENROUTER_API_KEY}`,
                  "Content-Type": "application/json"
                },
                body: JSON.stringify({
                  model: "google/gemini-3-flash-preview",
                  messages: [{ role: "user", content: contractPrompt }],
                  temperature: 0.3
                })
              });

              const contractData = await contractRes.json();
              const contractRaw = contractData.choices?.[0]?.message?.content;
              
              if (!contractRaw) {
                throw new Error("API contract model returned empty response.");
              }

              // Extract JSON from possible markdown code block
              let contractJsonStr = contractRaw.trim();
              const contractJsonMatch = contractJsonStr.match(/```(?:json)?\s*([\s\S]*?)```/);
              if (contractJsonMatch) {
                contractJsonStr = contractJsonMatch[1].trim();
              }

              let apiContract;
              try {
                apiContract = JSON.parse(contractJsonStr);
                console.log("âœ… API å¥‘çº¦è§£ææˆåŠŸ");
                console.log(`ğŸ“„ API å¥‘çº¦å†…å®¹:`);
                console.log("-".repeat(80));
                console.log(JSON.stringify(apiContract, null, 2));
                console.log("-".repeat(80));
                console.log("");
              } catch (error) {
                console.error("âŒ API å¥‘çº¦è§£æå¤±è´¥:", error);
                console.error("åŸå§‹å†…å®¹:", contractRaw);
                throw new Error(`Failed to parse API contract JSON: ${error.message}`);
              }

              // Normalize: ensure it's an array
              if (!Array.isArray(apiContract)) {
                apiContract = [apiContract];
              }

              // 4. Write API contract doc
              const apiDocPath = path.join(process.cwd(), "api/contract.json");
              fs.mkdirSync(path.dirname(apiDocPath), { recursive: true });
              fs.writeFileSync(apiDocPath, JSON.stringify(apiContract, null, 2), "utf8");

              // 4.1 Post analysis comment
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: [
                  "ğŸ“‹ **UI Spec åˆ†æå®Œæˆ**",
                  "",
                  `**æ‰¾åˆ° ${uiSpecs.length} ä¸ª UI Spec:**`,
                  specUrls.map((url, idx) => `${idx + 1}. ${url}`).join("\n"),
                  "",
                  userInstructions ? `**ç”¨æˆ·é¢å¤–æŒ‡ä»¤:**\n${userInstructions}\n` : "",
                  "ğŸ“„ **API å¥‘çº¦å·²ç”Ÿæˆï¼ˆå‰åç«¯å¯¹é½ï¼‰**",
                  "",
                  `**å…± ${apiContract.length} ä¸ªæ¥å£:**`,
                  apiContract.map((contract, idx) => 
                    `\n### ${idx + 1}. ${contract.method} ${contract.endpoint}\n\`\`\`json\n${JSON.stringify(contract, null, 2)}\n\`\`\``
                  ).join("\n"),
                  "",
                  "â³ å¼€å§‹ç”Ÿæˆåç«¯å®ç°ä»£ç ..."
                ].join("\n")
              });

              // 6. Read backend system files for project constraints
              // Read system files list from ARCHITECTURE.md
              const architectureDocPath = path.join(process.cwd(), "backend/ARCHITECTURE.md");
              let backendSystemFiles = [];
              
              if (fs.existsSync(architectureDocPath)) {
                const architectureDoc = fs.readFileSync(architectureDocPath, "utf8");
                // Extract system files list from markdown code block between markers
                const startMarker = "<!-- AGENT_SYSTEM_FILES_START -->";
                const endMarker = "<!-- AGENT_SYSTEM_FILES_END -->";
                const startIdx = architectureDoc.indexOf(startMarker);
                const endIdx = architectureDoc.indexOf(endMarker);
                
                if (startIdx !== -1 && endIdx !== -1) {
                  const filesSection = architectureDoc.substring(startIdx + startMarker.length, endIdx);
                  // Extract file paths from code block (lines starting with backend/)
                  const fileLines = filesSection.split('\n')
                    .map(line => line.trim())
                    .filter(line => line.startsWith('backend/') && !line.startsWith('```'));
                  
                  backendSystemFiles = fileLines;
                  console.log(`ğŸ“– ä» ARCHITECTURE.md è¯»å–åˆ° ${backendSystemFiles.length} ä¸ªç³»ç»Ÿæ–‡ä»¶`);
                } else {
                  console.log("âš ï¸  ARCHITECTURE.md ä¸­æœªæ‰¾åˆ°ç³»ç»Ÿæ–‡ä»¶æ ‡è®°ï¼Œä½¿ç”¨é»˜è®¤åˆ—è¡¨");
                  // Fallback to default list
                  backendSystemFiles = [
                    "backend/go.mod",
                    "backend/cmd/server/main.go",
                    "backend/internal/router/router.go",
                    "backend/internal/config/config.go",
                    "backend/internal/handlers/pomodoro.go",
                    "backend/internal/models/pomodoro.go",
                    "backend/internal/repository/pomodoro.go"
                  ];
                }
              } else {
                console.log("âš ï¸  ARCHITECTURE.md ä¸å­˜åœ¨ï¼Œä½¿ç”¨é»˜è®¤ç³»ç»Ÿæ–‡ä»¶åˆ—è¡¨");
                // Fallback to default list
                backendSystemFiles = [
                  "backend/go.mod",
                  "backend/cmd/server/main.go",
                  "backend/internal/router/router.go",
                  "backend/internal/config/config.go",
                  "backend/internal/handlers/pomodoro.go",
                  "backend/internal/models/pomodoro.go",
                  "backend/internal/repository/pomodoro.go"
                ];
              }

              const projectContext = {};
              const readFiles = [];

              for (const filePath of backendSystemFiles) {
                try {
                  const fullPath = path.join(process.cwd(), filePath);
                  if (fs.existsSync(fullPath)) {
                    const content = fs.readFileSync(fullPath, "utf8");
                    projectContext[filePath] = content;
                    readFiles.push(filePath);
                    console.log(`âœ… è¯»å–ç³»ç»Ÿæ–‡ä»¶: ${filePath} (${content.length} å­—ç¬¦)`);
                  } else {
                    console.log(`âš ï¸  æ–‡ä»¶ä¸å­˜åœ¨: ${filePath}`);
                  }
                } catch (error) {
                  console.error(`âŒ è¯»å–æ–‡ä»¶å¤±è´¥ ${filePath}:`, error.message);
                }
              }

              console.log(`ğŸ“š å…±è¯»å– ${readFiles.length} ä¸ªç³»ç»Ÿæ–‡ä»¶ä½œä¸ºé¡¹ç›®çº¦æŸ`);
              console.log("");

              // 6.1 Format project context
              const projectContextText = Object.entries(projectContext)
                .map(([filePath, content]) => {
                  return `## ${filePath}\n\`\`\`go\n${content}\n\`\`\``;
                })
                .join("\n\n");

              // 7. Create branch
              const branchName = `agent-be-${issue_number}-${Date.now()}`;
              execSync(`git checkout -b ${branchName}`);

              // 8. Prepare prompt for anthropics/claude-code-action@v1
              const backendPrompt = `You are the Backend Execution Agent.

                RULES:
                - Follow API contract strictly
                - Do not infer UI behavior
                - No persistence unless specified
                - Keep code minimal and explicit
                - Follow existing project architecture patterns

                PATH CONSTRAINTS:
                - Implementation files must be under backend/
                - API docs must be under api/
                - DO NOT modify any files under .github/workflows/ (workflow files are off-limits)
                - Follow the existing directory structure:
                  * backend/cmd/server/main.go - Entry point
                  * backend/internal/router/router.go - Route definitions
                  * backend/internal/handlers/ - HTTP handlers
                  * backend/internal/models/ - Data models
                  * backend/internal/repository/ - Data access layer
                  * backend/internal/config/ - Configuration
                  * backend/internal/middleware/ - Middleware
                  * backend/internal/database/ - Database connection
                  * backend/internal/cache/ - Cache connection

                ====================
                PROJECT ARCHITECTURE & CONSTRAINTS
                ====================
                ä»¥ä¸‹æ˜¯ä»ç°æœ‰ä»£ç åº“ä¸­è¯»å–çš„ç³»ç»Ÿæ–‡ä»¶ï¼Œè¯·ä¸¥æ ¼éµå¾ªè¿™äº›æ¶æ„æ¨¡å¼å’Œä»£ç é£æ ¼ï¼š

                ${projectContextText}

                ====================
                API CONTRACT (${apiContract.length} endpoints)
                ====================
                ${JSON.stringify(apiContract, null, 2)}

                ${userInstructions ? `====================
                USER INSTRUCTIONS
                ====================
                ${userInstructions}` : ""}

                ====================
                UI SPEC SOURCES
                ====================
                ${specUrls.map((url, idx) => `${idx + 1}. ${url}`).join("\n")}

                ====================
                IMPLEMENTATION REQUIREMENTS
                ====================
                1. éµå¾ªç°æœ‰ä»£ç æ¶æ„æ¨¡å¼ï¼ˆå‚è€ƒä¸Šé¢çš„ç³»ç»Ÿæ–‡ä»¶ï¼‰
                2. ä½¿ç”¨ç›¸åŒçš„åŒ…ç»“æ„å’Œå‘½åçº¦å®š
                3. éµå¾ªç›¸åŒçš„é”™è¯¯å¤„ç†æ¨¡å¼
                4. ä½¿ç”¨ç›¸åŒçš„æ—¥å¿—è®°å½•æ–¹å¼ï¼ˆzap.Loggerï¼‰
                5. éµå¾ªç›¸åŒçš„è·¯ç”±æ³¨å†Œæ¨¡å¼ï¼ˆåœ¨ router.go ä¸­æ³¨å†Œï¼‰
                6. å¦‚æœæ¶‰åŠæ•°æ®åº“æ“ä½œï¼Œä½¿ç”¨ Repository æ¨¡å¼
                7. å¦‚æœæ¶‰åŠæ¨¡å‹ï¼Œéµå¾ª GORM æ¨¡å¼
                8. æ‰€æœ‰æ–‡ä»¶è·¯å¾„å¿…é¡»åœ¨ backend/ ç›®å½•ä¸‹

                è¯·ç”Ÿæˆå®Œæ•´çš„åç«¯å®ç°ä»£ç ï¼Œåˆ›å»ºæ‰€æœ‰å¿…è¦çš„æ–‡ä»¶ã€‚`;

              // Set output for anthropics/claude-code-action@v1
              core.setOutput("prompt_content", backendPrompt);
              core.setOutput("branch_name", branchName);
              
              console.log("ğŸ“ Prompt prepared for anthropics/claude-code-action@v1");
              console.log(`ğŸ“ Prompt length: ${backendPrompt.length} characters`);
              console.log("âœ… Context prepared. Next step will use anthropics/claude-code-action@v1");
              
              // Note: Code generation will be done by anthropics/claude-code-action@v1 in the next step
              // We skip file writing here as it will be handled by Claude Code Action
            }

            await runBackendAgent();

      - name: Run Claude Code Action
        uses: anthropics/claude-code-action@v1
        env:
          ANTHROPIC_BASE_URL: https://openrouter.ai/api
        with:
          # å›ºå®šæ ‡å‡†é…ç½®
          anthropic_api_key: ${{ secrets.OPENROUTER_API_KEY }}
          github_token: ${{ github.token }}
          track_progress: true
          prompt: ${{ steps.prepare-context.outputs.prompt_content }}

      - name: Vibe Backend Agent - Finalize and Create PR
        uses: actions/github-script@v7
        id: finalize
        env:
          BRANCH_NAME: ${{ steps.prepare-context.outputs.branch_name }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        with:
          script: |
            const fs = require("fs");
            const path = require("path");
            const { execSync } = require("child_process");

            async function finalizeBackendAgent() {
              const branchName = process.env.BRANCH_NAME;
              const issue_number = Number(process.env.ISSUE_NUMBER);
              const { owner, repo } = context.repo;
              
              // Track file changes
              const fileChanges = {
                created: [],
                modified: [],
                errors: []
              };
              
              // Check if there are any changes before committing
              let hasChanges = false;
              try {
                // Check for unstaged changes
                const gitStatus = execSync("git status --porcelain", { encoding: "utf8" });
                const changedFiles = gitStatus.split("\n")
                  .filter(line => line.trim())
                  .map(line => {
                    const status = line.substring(0, 2).trim();
                    const file = line.substring(3).trim();
                    return { status, file };
                  });
                
                console.log(`ğŸ“‹ Git status: ${changedFiles.length} changed files`);
                
                for (const { status, file } of changedFiles) {
                  if (file.startsWith("backend/") || file.startsWith("api/")) {
                    hasChanges = true;
                    if (status.includes("A") || status.includes("??")) {
                      fileChanges.created.push(file);
                    } else if (status.includes("M") || status.includes("D")) {
                      fileChanges.modified.push(file);
                    }
                  }
                }
                
                // Also check if there are staged changes
                try {
                  const diffCached = execSync("git diff --cached --name-only", { encoding: "utf8" });
                  if (diffCached.trim()) {
                    hasChanges = true;
                    const stagedFiles = diffCached.split("\n").filter(line => line.trim());
                    stagedFiles.forEach(file => {
                      if ((file.startsWith("backend/") || file.startsWith("api/")) && !fileChanges.modified.includes(file) && !fileChanges.created.includes(file)) {
                        if (fs.existsSync(file)) {
                          fileChanges.modified.push(file);
                        } else {
                          fileChanges.created.push(file);
                        }
                      }
                    });
                  }
                } catch (e) {
                  // No staged changes, continue
                }
                
                console.log(`ğŸ“ File changes: ${fileChanges.created.length} created, ${fileChanges.modified.length} modified`);
              } catch (error) {
                console.error("Error tracking file changes:", error);
              }
              
              // Only commit and create PR if there are actual changes
              if (!hasChanges) {
                console.log("âš ï¸  No changes detected. Skipping commit and PR creation.");
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number,
                  body: [
                    "âš ï¸ **Backend Agent å®Œæˆï¼ˆæ— å˜æ›´ï¼‰**",
                    "",
                    "`anthropics/claude-code-action@v1` æ²¡æœ‰ç”Ÿæˆä»»ä½•æ–°çš„ä»£ç æ–‡ä»¶ã€‚",
                    "",
                    "å¯èƒ½çš„åŸå› ï¼š",
                    "- UI Spec ä¸­ä¸éœ€è¦æ–°çš„åç«¯å®ç°",
                    "- æ‰€æœ‰éœ€è¦çš„ä»£ç å·²ç»å­˜åœ¨",
                    "- Claude åˆ¤æ–­æ— éœ€ä¿®æ”¹ç°æœ‰ä»£ç ",
                    "",
                    "**ğŸ“ æ–‡ä»¶å˜æ›´:**",
                    "- æ— ",
                    "",
                    "å¦‚æœç¡®å®éœ€è¦ç”Ÿæˆä»£ç ï¼Œè¯·æ£€æŸ¥ UI Spec æ˜¯å¦æ˜ç¡®æŒ‡å®šäº†åç«¯éœ€æ±‚ã€‚"
                  ].join("\n")
                });
                return;
              }
              
              // Restore any workflow files that were modified (they should not be changed)
              try {
                const workflowFiles = execSync("git diff --name-only .github/workflows/", { encoding: "utf8" }).trim();
                if (workflowFiles) {
                  console.log("âš ï¸  æ£€æµ‹åˆ° workflow æ–‡ä»¶è¢«ä¿®æ”¹ï¼Œæ­£åœ¨æ¢å¤...");
                  execSync("git checkout HEAD -- .github/workflows/", { encoding: "utf8" });
                  console.log("âœ… Workflow æ–‡ä»¶å·²æ¢å¤");
                }
              } catch (e) {
                // No workflow files changed, continue
              }
              
              // Commit changes
              try {
                execSync("git add .", { encoding: "utf8" });
                
                // Check if there's anything to commit after staging
                const diffAfterAdd = execSync("git diff --cached --name-only", { encoding: "utf8" });
                if (!diffAfterAdd.trim()) {
                  console.log("âš ï¸  No changes to commit after staging.");
                  await github.rest.issues.createComment({
                    owner,
                    repo,
                    issue_number,
                    body: [
                      "âš ï¸ **Backend Agent å®Œæˆï¼ˆæ— å˜æ›´ï¼‰**",
                      "",
                      "æš‚å­˜åæ²¡æœ‰å¯æäº¤çš„å˜æ›´ã€‚",
                      "",
                      "**ğŸ“ æ–‡ä»¶å˜æ›´:**",
                      "- æ— "
                    ].join("\n")
                  });
                  return;
                }
                
                execSync(`git commit -m "feat: backend implementation for parsing (#${issue_number})"`, { encoding: "utf8" });
                execSync(`git push origin ${branchName}`, { encoding: "utf8" });
                console.log("âœ… Changes committed and pushed");
              } catch (error) {
                console.error("Error committing changes:", error);
                fileChanges.errors.push(`æäº¤å¤±è´¥: ${error.message}`);
              }
              
              // Create PR only if we have commits
              let pr = null;
              try {
                // Check if branch has commits ahead of main
                const diffMain = execSync(`git rev-list --count main..${branchName}`, { encoding: "utf8" }).trim();
                if (diffMain === "0") {
                  console.log("âš ï¸  Branch has no commits ahead of main. Skipping PR creation.");
                  await github.rest.issues.createComment({
                    owner,
                    repo,
                    issue_number,
                    body: [
                      "âš ï¸ **Backend Agent å®Œæˆï¼ˆæ— å˜æ›´ï¼‰**",
                      "",
                      "åˆ†æ”¯ä¸ main åˆ†æ”¯æ²¡æœ‰å·®å¼‚ï¼Œæ— æ³•åˆ›å»º PRã€‚",
                      "",
                      "**ğŸ“ æ–‡ä»¶å˜æ›´:**",
                      "",
                      `**æ–°å»º (${fileChanges.created.length}):**`,
                      fileChanges.created.length > 0
                        ? fileChanges.created.map(f => `- \`${f}\``).join("\n")
                        : "- æ— ",
                      "",
                      `**ä¿®æ”¹ (${fileChanges.modified.length}):**`,
                      fileChanges.modified.length > 0
                        ? fileChanges.modified.map(f => `- \`${f}\``).join("\n")
                        : "- æ— ",
                      "",
                      fileChanges.errors.length > 0 ? [
                        "**âš ï¸ é”™è¯¯:**",
                        fileChanges.errors.map(e => `- ${e}`).join("\n"),
                        ""
                      ].join("\n") : ""
                    ].join("\n")
                  });
                  return;
                }
                
                pr = await github.rest.pulls.create({
                  owner,
                  repo,
                  title: `Backend: parsing implementation (#${issue_number})`,
                  head: branchName,
                  base: "main",
                  body: [
                    "This PR was generated by Vibe Backend Agent using anthropics/claude-code-action@v1.",
                    "",
                    "Includes:",
                    "- API contract under /api",
                    "- Backend implementation under /backend",
                    "- UI contract respected"
                  ].join("\n")
                });
                console.log(`âœ… PR created: ${pr.data.html_url}`);
              } catch (error) {
                console.error("Error creating PR:", error);
                fileChanges.errors.push(`PR åˆ›å»ºå¤±è´¥: ${error.message}`);
              }
              
              // Comment back to issue
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: [
                  pr ? "âœ… **Backend Agent å®Œæˆ**" : "âš ï¸ **Backend Agent å®Œæˆï¼ˆéƒ¨åˆ†å¤±è´¥ï¼‰**",
                  "",
                  pr ? `ğŸ”— PR: ${pr.data.html_url}` : "",
                  "",
                  "**ğŸ“ æ–‡ä»¶å˜æ›´:**",
                  "",
                  `**æ–°å»º (${fileChanges.created.length}):**`,
                  fileChanges.created.length > 0
                    ? fileChanges.created.map(f => `- \`${f}\``).join("\n")
                    : "- æ— ",
                  "",
                  `**ä¿®æ”¹ (${fileChanges.modified.length}):**`,
                  fileChanges.modified.length > 0
                    ? fileChanges.modified.map(f => `- \`${f}\``).join("\n")
                    : "- æ— ",
                  "",
                  fileChanges.errors.length > 0 ? [
                    "**âš ï¸ é”™è¯¯:**",
                    fileChanges.errors.map(e => `- ${e}`).join("\n"),
                    ""
                  ].join("\n") : "",
                  "- âœ… API å¥‘çº¦å·²å†™å…¥ `/api/contract.json`",
                  "- âœ… å®ç°ä»£ç ä½äº `/backend`",
                  "- âœ… ä½¿ç”¨ anthropics/claude-code-action@v1 ç”Ÿæˆä»£ç ",
                  "- âœ… éµå¾ªç°æœ‰é¡¹ç›®æ¶æ„æ¨¡å¼",
                  "- âœ… UI è§„æ ¼ä¸¥æ ¼éµå®ˆ"
                ].join("\n")
              });
            }

            await finalizeBackendAgent();
