name: Vibe Frontend Agent

on:
  issue_comment:
    types: [created]

jobs:
  frontend-agent:
    if: contains(github.event.comment.body, '/agent-fe')
    runs-on: ubuntu-latest

    permissions:
      issues: write
      contents: write
      pull-requests: write

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Setup Git
        run: |
          git config user.name "vibe-frontend-agent"
          git config user.email "agent@vibe.dev"

      - name: Vibe Frontend Agent - Generate Code and Open PR
        uses: actions/github-script@v7
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        with:
          script: |
            const fs = require("fs");
            const path = require("path");
            const { execSync } = require("child_process");

            async function runFrontendAgent() {
              const { owner, repo } = context.repo;
              const issue_number = context.issue.number;
              const commentBody = context.payload.comment.body;

              // 1. Extract UI Spec comment URL (supports both raw URL and markdown link format)
              // GitHub auto-converts URLs to markdown: [#139 (comment)](https://...)
              const match = commentBody.match(
                /https:\/\/github\.com\/[^\s\)]+\/issues\/\d+#issuecomment-\d+/
              );

              if (!match) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number,
                  body: [
                    "âŒ **ç¼ºå°‘è¯„è®º URL**",
                    "",
                    "ç”¨æ³•: `/agent-fe <github issue comment url>`",
                    "",
                    "ç¤ºä¾‹:",
                    "```",
                    "/agent-fe https://github.com/owner/repo/issues/1#issuecomment-123456",
                    "è¯·ä½¿ç”¨æ·±è‰²ä¸»é¢˜",
                    "```"
                  ].join("\n")
                });
                return;
              }

              const commentUrl = match[0];
              const commentId = commentUrl.split("#issuecomment-")[1];

              // 1.1 Extract user instructions (text after URL)
              const userInstructions = commentBody
                .replace(/\/agent-fe\s*/, "")
                .replace(commentUrl, "")
                .trim();

              // 2. Fetch UI Spec comment
              const commentRes = await github.rest.issues.getComment({
                owner,
                repo,
                comment_id: Number(commentId)
              });

              const frozenUISpec = commentRes.data.body;

              // 2.1 Analyze requirements and generate todolist
              const analysisPrompt = `ä½ æ˜¯ä¸€ä¸ªå‰ç«¯éœ€æ±‚åˆ†æä¸“å®¶ã€‚è¯·åˆ†æä»¥ä¸‹ UI è§„æ ¼å’Œç”¨æˆ·æŒ‡ä»¤ï¼Œç”Ÿæˆéœ€æ±‚åˆ†æå’Œå¾…åŠæ¸…å•ã€‚

              UI è§„æ ¼æ¥æº: ${commentUrl}
              
              UI è§„æ ¼å†…å®¹:
              ${frozenUISpec}
              
              ${userInstructions ? `ç”¨æˆ·é¢å¤–æŒ‡ä»¤:\n${userInstructions}` : ""}
              
              è¯·è¿”å› JSON æ ¼å¼:
              {
                "analysis": "éœ€æ±‚åˆ†ææ€»ç»“ï¼ˆ2-3å¥è¯ï¼‰",
                "todolist": [
                  "å¾…åŠé¡¹1",
                  "å¾…åŠé¡¹2",
                  "å¾…åŠé¡¹3"
                ]
              }
              
              åªè¿”å› JSONï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚`;

              const analysisRes = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                method: "POST",
                headers: {
                  "Authorization": `Bearer ${process.env.OPENROUTER_API_KEY}`,
                  "Content-Type": "application/json"
                },
                body: JSON.stringify({
                  model: "google/gemini-3-flash-preview",
                  messages: [
                    { role: "user", content: analysisPrompt }
                  ],
                  temperature: 0.3
                })
              });

              const analysisData = await analysisRes.json();
              const analysisRaw = analysisData.choices?.[0]?.message?.content;
              
              let analysisResult = { analysis: "", todolist: [] };
              if (analysisRaw) {
                let analysisJsonStr = analysisRaw.trim();
                const analysisJsonMatch = analysisJsonStr.match(/```(?:json)?\s*([\s\S]*?)```/);
                if (analysisJsonMatch) {
                  analysisJsonStr = analysisJsonMatch[1].trim();
                }
                try {
                  analysisResult = JSON.parse(analysisJsonStr);
                } catch (e) {
                  console.error("Failed to parse analysis JSON:", e);
                  analysisResult.analysis = "éœ€æ±‚åˆ†æå®Œæˆ";
                  analysisResult.todolist = ["å®ç°å‰ç«¯ç•Œé¢"];
                }
              }

              // 2.2 Post analysis and todolist comment
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: [
                  "ğŸ“‹ **éœ€æ±‚åˆ†æå®Œæˆ**",
                  "",
                  "### éœ€æ±‚åˆ†æ",
                  analysisResult.analysis || "æ­£åœ¨åˆ†æéœ€æ±‚...",
                  "",
                  "### ğŸ“ å¾…åŠæ¸…å•",
                  analysisResult.todolist.map((item, idx) => `- [ ] ${item}`).join("\n"),
                  "",
                  "â³ å¼€å§‹ç”Ÿæˆä»£ç ..."
                ].join("\n")
              });

              // 3. Create new branch
              const branchName = `agent-fe-${issue_number}-${Date.now()}`;
              execSync(`git checkout -b ${branchName}`);

              // 4. Build system prompt and user prompt
              const systemPrompt = `You are the **Frontend Execution Agent**.
              
              Your task:
              Generate COMPLETE frontend code and output it in a MACHINE-PARSABLE FORMAT.
              
              ====================
              RULES (STRICT)
              ====================
              - UI spec is a contract
              - No UI redesign
              - No extra features
              - No persistence
              - Single Page Interface
              - Next.js App Router
              - TypeScript strict
              - Tailwind CSS
              
              ====================
              PATH CONSTRAINTS (STRICT - NO EXCEPTIONS)
              ====================
              ALL file paths MUST start with "frontend/"
              You CANNOT create files outside the frontend/ directory.
              You CANNOT create files in backend/, root, or any other directory.
              
              Examples:
              - âœ… "frontend/app/page.tsx"
              - âœ… "frontend/components/ui/button.tsx"
              - âŒ "app/page.tsx" (REJECTED - outside frontend/)
              - âŒ "components/button.tsx" (REJECTED - outside frontend/)
              - âŒ "backend/api/handler.go" (REJECTED - backend files not allowed)
              - âŒ "../frontend/app/page.tsx" (REJECTED - path traversal not allowed)
              
              ONLY files inside frontend/ directory are allowed.
              
              ====================
              OUTPUT FORMAT (MANDATORY)
              ====================
              Return ONLY valid JSON in this exact shape:
              
              {
                "files": [
                  {
                    "path": "frontend/relative/path/to/file.tsx",
                    "content": "full file content"
                  }
                ]
              }
              
              No markdown.
              No explanations.
              No extra text.`;
              
              const userPrompt = `
              ====================
              SOURCE OF TRUTH
              ${commentUrl}
              ====================
              
              ${frozenUISpec}
              
              ${userInstructions ? `====================
              USER INSTRUCTIONS
              ====================
              ${userInstructions}` : ""}
              
              ${analysisResult.todolist.length > 0 ? `====================
              TODO LIST (å‚è€ƒ)
              ====================
              ${analysisResult.todolist.map((item, idx) => `${idx + 1}. ${item}`).join("\n")}` : ""}`;

              // 5. Call model
              const res = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                method: "POST",
                headers: {
                  "Authorization": `Bearer ${process.env.OPENROUTER_API_KEY}`,
                  "Content-Type": "application/json"
                },
                body: JSON.stringify({
                  model: "google/gemini-3-flash-preview",
                  messages: [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: userPrompt }
                  ],
                  temperature: 0.3
                })
              });

              const data = await res.json();
              const raw = data.choices?.[0]?.message?.content;

              if (!raw) {
                throw new Error("Model returned empty response.");
              }

              // 5.1 Extract JSON from possible markdown code block
              let jsonStr = raw.trim();
              const jsonMatch = jsonStr.match(/```(?:json)?\s*([\s\S]*?)```/);
              if (jsonMatch) {
                jsonStr = jsonMatch[1].trim();
              }

              let parsed;
              try {
                parsed = JSON.parse(jsonStr);
              } catch {
                throw new Error("Model output is not valid JSON.");
              }

              // 6. Write files with path validation
              const generatedFiles = [];
              const fileChanges = {
                created: [],
                modified: [],
                errors: []
              };
              
              for (const file of parsed.files) {
                // 6.1 Validate path - STRICT: ONLY frontend/ directory allowed
                let normalizedPath = file.path.trim();
                
                // Remove leading slash if present
                if (normalizedPath.startsWith("/")) {
                  normalizedPath = normalizedPath.substring(1);
                }
                
                // STRICT CHECK: Path MUST start with "frontend/" - NO AUTO-FIX
                if (!normalizedPath.startsWith("frontend/")) {
                  fileChanges.errors.push(`è·¯å¾„è¢«æ‹’ç»: ${file.path} - åªå…è®¸åœ¨ frontend/ ç›®å½•ä¸‹åˆ›å»ºæ–‡ä»¶`);
                  continue;
                }
                
                // Prevent path traversal attacks (even within frontend/)
                if (normalizedPath.includes("../") || normalizedPath.includes("..\\")) {
                  fileChanges.errors.push(`è·¯å¾„ä¸å®‰å…¨: ${file.path} - ä¸å…è®¸ä½¿ç”¨è·¯å¾„éå†`);
                  continue;
                }
                
                // Additional check: ensure normalized path is still within frontend/
                // This prevents paths like "frontend/../../other-dir/file"
                const pathParts = normalizedPath.split(path.sep);
                if (pathParts[0] !== "frontend" || pathParts.includes("..")) {
                  fileChanges.errors.push(`è·¯å¾„æ— æ•ˆ: ${file.path} - å¿…é¡»åœ¨ frontend/ ç›®å½•å†…`);
                  continue;
                }
                
                const fullPath = path.join(process.cwd(), normalizedPath);
                
                // Check if file already exists
                const fileExists = fs.existsSync(fullPath);
                
                try {
                  fs.mkdirSync(path.dirname(fullPath), { recursive: true });
                  fs.writeFileSync(fullPath, file.content, "utf8");
                  generatedFiles.push(normalizedPath);
                  
                  if (fileExists) {
                    fileChanges.modified.push(normalizedPath);
                  } else {
                    fileChanges.created.push(normalizedPath);
                  }
                } catch (error) {
                  fileChanges.errors.push(`å†™å…¥å¤±è´¥: ${normalizedPath} - ${error.message}`);
                }
              }

              // 6.1 Analyze completion status (before recording changelog)
              const completionPrompt = `è¯·åˆ†æä»¥ä¸‹å†…å®¹ï¼Œå¯¹æ¯”å¾…åŠæ¸…å•å’Œå®é™…å®Œæˆæƒ…å†µã€‚

              å¾…åŠæ¸…å•:
              ${analysisResult.todolist.map((item, idx) => `${idx + 1}. ${item}`).join("\n")}
              
              å®é™…ç”Ÿæˆçš„æ–‡ä»¶:
              ${generatedFiles.map((f, idx) => `${idx + 1}. ${f}`).join("\n")}
              
              è¯·è¿”å› JSON æ ¼å¼:
              {
                "completed": ["å·²å®Œæˆé¡¹1", "å·²å®Œæˆé¡¹2"],
                "notCompleted": ["æœªå®Œæˆé¡¹1", "æœªå®Œæˆé¡¹2"],
                "summary": "å®Œæˆæƒ…å†µæ€»ç»“ï¼ˆ1-2å¥è¯ï¼‰"
              }
              
              åªè¿”å› JSONï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚`;

              const completionRes = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                method: "POST",
                headers: {
                  "Authorization": `Bearer ${process.env.OPENROUTER_API_KEY}`,
                  "Content-Type": "application/json"
                },
                body: JSON.stringify({
                  model: "google/gemini-3-flash-preview",
                  messages: [
                    { role: "user", content: completionPrompt }
                  ],
                  temperature: 0.3
                })
              });

              const completionData = await completionRes.json();
              const completionRaw = completionData.choices?.[0]?.message?.content;
              
              let completionStatus = { completed: [], notCompleted: [], summary: "" };
              if (completionRaw) {
                let completionJsonStr = completionRaw.trim();
                const completionJsonMatch = completionJsonStr.match(/```(?:json)?\s*([\s\S]*?)```/);
                if (completionJsonMatch) {
                  completionJsonStr = completionJsonMatch[1].trim();
                }
                try {
                  completionStatus = JSON.parse(completionJsonStr);
                } catch (e) {
                  console.error("Failed to parse completion JSON:", e);
                  completionStatus.completed = analysisResult.todolist;
                  completionStatus.summary = "ä»£ç å·²ç”Ÿæˆ";
                }
              }

              // 6.2 Record changes to changelog
              const changelogPath = path.join(process.cwd(), "frontend/AGENT_CHANGELOG.md");
              const timestamp = new Date().toISOString();
              const changelogEntry = [
                `## ${timestamp} - Issue #${issue_number}`,
                "",
                `**UI Spec:** ${commentUrl}`,
                userInstructions ? `**ç”¨æˆ·æŒ‡ä»¤:** ${userInstructions}` : "",
                "",
                "### ğŸ“ éœ€æ±‚åˆ†æ",
                analysisResult.analysis || "éœ€æ±‚åˆ†æå®Œæˆ",
                "",
                "### âœ… å·²å®Œæˆ",
                completionStatus.completed.length > 0
                  ? completionStatus.completed.map(item => `- ${item}`).join("\n")
                  : "- ä»£ç å·²ç”Ÿæˆ",
                "",
                completionStatus.notCompleted.length > 0 ? [
                  "### âŒ æœªå®Œæˆ",
                  completionStatus.notCompleted.map(item => `- ${item}`).join("\n"),
                  ""
                ].join("\n") : "",
                "### ğŸ“ æ–‡ä»¶å˜æ›´",
                "",
                `**æ–°å»ºæ–‡ä»¶ (${fileChanges.created.length}):**`,
                fileChanges.created.length > 0
                  ? fileChanges.created.map(f => `- \`${f}\``).join("\n")
                  : "- æ— ",
                "",
                `**ä¿®æ”¹æ–‡ä»¶ (${fileChanges.modified.length}):**`,
                fileChanges.modified.length > 0
                  ? fileChanges.modified.map(f => `- \`${f}\``).join("\n")
                  : "- æ— ",
                "",
                fileChanges.errors.length > 0 ? [
                  `**é”™è¯¯ (${fileChanges.errors.length}):**`,
                  fileChanges.errors.map(e => `- âš ï¸ ${e}`).join("\n"),
                  ""
                ].join("\n") : "",
                "---",
                ""
              ].join("\n");
              
              // Read existing changelog or create new one
              let changelogContent = "";
              if (fs.existsSync(changelogPath)) {
                changelogContent = fs.readFileSync(changelogPath, "utf8");
              } else {
                changelogContent = [
                  "# Frontend Agent å˜æ›´æ—¥å¿—",
                  "",
                  "æ­¤æ–‡ä»¶ç”± Frontend Agent è‡ªåŠ¨ç”Ÿæˆå’Œç»´æŠ¤ï¼Œè®°å½•æ‰€æœ‰ä»£ç å˜æ›´å†å²ã€‚",
                  "",
                  "---",
                  ""
                ].join("\n");
              }
              
              // Prepend new entry
              const updatedChangelog = changelogEntry + changelogContent;
              fs.writeFileSync(changelogPath, updatedChangelog, "utf8");
              
              // Add changelog to generated files if it's new or modified
              if (!generatedFiles.includes("frontend/AGENT_CHANGELOG.md")) {
                generatedFiles.push("frontend/AGENT_CHANGELOG.md");
                fileChanges.created.push("frontend/AGENT_CHANGELOG.md");
              } else if (!fileChanges.modified.includes("frontend/AGENT_CHANGELOG.md")) {
                fileChanges.modified.push("frontend/AGENT_CHANGELOG.md");
              }

              // 7. Commit changes
              execSync("git add .");
              execSync(`git commit -m "feat: implement frontend from frozen UI spec (#${issue_number})"`);
              execSync(`git push origin ${branchName}`);

              // 8. Create PR
              const pr = await github.rest.pulls.create({
                owner,
                repo,
                title: `Frontend: implement frozen UI spec (#${issue_number})`,
                head: branchName,
                base: "main",
                body: [
                  "This PR was generated by Vibe Frontend Agent.",
                  "",
                  `UI Spec Source: ${commentUrl}`,
                  "",
                  "### å®Œæˆæƒ…å†µ",
                  completionStatus.summary || "ä»£ç å·²ç”Ÿæˆ",
                  "",
                  "**å·²å®Œæˆ:**",
                  completionStatus.completed.map(item => `- âœ… ${item}`).join("\n") || "- ä»£ç å·²ç”Ÿæˆ",
                  "",
                  completionStatus.notCompleted.length > 0 ? [
                    "**æœªå®Œæˆ:**",
                    completionStatus.notCompleted.map(item => `- âŒ ${item}`).join("\n"),
                    ""
                  ].join("\n") : "",
                  "- UI spec treated as immutable contract",
                  "- No UI inference or redesign",
                  "- Ready for review"
                ].join("\n")
              });

              // 9. Comment back to issue
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: [
                  "âœ… **Frontend implementation completed**",
                  "",
                  `ğŸ”— PR: ${pr.data.html_url}`,
                  "",
                  "### ğŸ“Š å®Œæˆæƒ…å†µ",
                  completionStatus.summary || "ä»£ç å·²ç”Ÿæˆå¹¶æäº¤",
                  "",
                  "**âœ… å·²å®Œæˆ:**",
                  completionStatus.completed.length > 0 
                    ? completionStatus.completed.map(item => `- ${item}`).join("\n")
                    : "- ä»£ç å·²ç”Ÿæˆ",
                  "",
                  completionStatus.notCompleted.length > 0 ? [
                    "**âŒ æœªå®Œæˆ:**",
                    completionStatus.notCompleted.map(item => `- ${item}`).join("\n"),
                    ""
                  ].join("\n") : "",
                  "**ğŸ“ æ–‡ä»¶å˜æ›´:**",
                  "",
                  `**æ–°å»º (${fileChanges.created.length}):**`,
                  fileChanges.created.length > 0
                    ? fileChanges.created.map(f => `- \`${f}\``).join("\n")
                    : "- æ— ",
                  "",
                  `**ä¿®æ”¹ (${fileChanges.modified.length}):**`,
                  fileChanges.modified.length > 0
                    ? fileChanges.modified.map(f => `- \`${f}\``).join("\n")
                    : "- æ— ",
                  "",
                  fileChanges.errors.length > 0 ? [
                    "**âš ï¸ é”™è¯¯:**",
                    fileChanges.errors.map(e => `- ${e}`).join("\n"),
                    ""
                  ].join("\n") : "",
                  "**ğŸ“ å˜æ›´æ—¥å¿—:**",
                  `æ‰€æœ‰å˜æ›´å·²è®°å½•åˆ° \`frontend/AGENT_CHANGELOG.md\``,
                  "",
                  "---",
                  "Notes:",
                  "- âœ… ä¸¥æ ¼è·¯å¾„çº¦æŸï¼šæ‰€æœ‰æ–‡ä»¶ä»…åœ¨ `frontend/` ç›®å½•ä¸‹",
                  "- âœ… ç¦æ­¢åœ¨ `frontend/` ç›®å½•å¤–åˆ›å»ºä»»ä½•æ–‡ä»¶",
                  "- âœ… å˜æ›´å†å²å·²è®°å½•åˆ° `frontend/AGENT_CHANGELOG.md`",
                  "- Frontend code generated and committed",
                  "- UI spec respected strictly",
                  "- No persistence added"
                ].join("\n")
              });
            }

            await runFrontendAgent();
